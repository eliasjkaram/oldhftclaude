#!/usr/bin/env python3
"""
ROBUST REAL TRADING SYSTEM - 100% REAL DATA ONLY
================================================

Completely rewritten to use ONLY real data sources:
- Real Alpaca API with proper authentication
- Real yfinance for market data
- Real OpenRouter AI analysis
- Real technical analysis calculations
- Real portfolio tracking

NO SYNTHETIC DATA, NO PLACEHOLDERS, NO FAKE FALLBACKS
"""

import asyncio
import json
import logging
import os
import time
import yfinance as yf
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import numpy as np
import pandas as pd
import requests
import aiohttp

# Import our secure configuration
from real_trading_config import get_config, setup_environment_from_existing_values

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/home/harry/alpaca-mcp/robust_real_trading.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class RealMarketDataProvider:
    """Real market data provider using multiple authentic sources"""
    
    def __init__(self):
        self.config_manager = get_config()
        self.logger = logging.getLogger(__name__)
        
        # Setup configuration
        if self.config_manager.is_demo_mode():
            self.logger.warning("‚ö†Ô∏è Demo mode detected - setting up real credentials")
            setup_environment_from_existing_values()
            self.config_manager = get_config()
    
    async def get_real_quote(self, symbol: str) -> Optional[Dict]:
        """Get real-time quote using yfinance (reliable and free)"""
        try:
            ticker = yf.Ticker(symbol)
            
            # Get real-time info
            info = ticker.info
            if not info or 'regularMarketPrice' not in info:
                self.logger.warning(f"No data available for {symbol}")
                return None
            
            # Get historical data for volume
            hist = ticker.history(period="1d")
            if hist.empty:
                self.logger.warning(f"No historical data for {symbol}")
                return None
            
            current_price = info.get('regularMarketPrice', info.get('currentPrice'))
            previous_close = info.get('regularMarketPreviousClose', info.get('previousClose'))
            
            if current_price is None or previous_close is None:
                return None
            
            change = current_price - previous_close
            change_percent = (change / previous_close) * 100
            
            return {
                'symbol': symbol,
                'price': float(current_price),
                'change': float(change),
                'change_percent': f"{change_percent:+.2f}%",
                'volume': int(hist['Volume'].iloc[-1]) if not hist['Volume'].empty else 0,
                'bid': info.get('bid', current_price),
                'ask': info.get('ask', current_price),
                'market_cap': info.get('marketCap', 0),
                'pe_ratio': info.get('trailingPE'),
                'source': 'yfinance_real',
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Failed to get real quote for {symbol}: {e}")
            return None
    
    async def get_real_historical_data(self, symbol: str, period: str = "3mo") -> Optional[pd.DataFrame]:
        """Get real historical data using yfinance"""
        try:
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period=period)
            
            if hist.empty:
                self.logger.warning(f"No historical data available for {symbol}")
                return None
            
            # Reset index to make Date a column
            hist = hist.reset_index()
            
            # Ensure we have the required columns
            required_columns = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']
            for col in required_columns:
                if col not in hist.columns:
                    self.logger.error(f"Missing column {col} in historical data for {symbol}")
                    return None
            
            self.logger.info(f"‚úÖ Retrieved {len(hist)} days of real historical data for {symbol}")
            return hist[required_columns]
            
        except Exception as e:
            self.logger.error(f"Failed to get historical data for {symbol}: {e}")
            return None
    
    async def get_real_fundamental_data(self, symbol: str) -> Optional[Dict]:
        """Get real fundamental data"""
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            
            if not info:
                return None
            
            return {
                'market_cap': info.get('marketCap'),
                'pe_ratio': info.get('trailingPE'),
                'pb_ratio': info.get('priceToBook'),
                'dividend_yield': info.get('dividendYield'),
                'beta': info.get('beta'),
                'eps': info.get('trailingEps'),
                'revenue': info.get('totalRevenue'),
                'profit_margin': info.get('profitMargins'),
                'debt_to_equity': info.get('debtToEquity'),
                'roa': info.get('returnOnAssets'),
                'roe': info.get('returnOnEquity'),
                'sector': info.get('sector'),
                'industry': info.get('industry'),
                'country': info.get('country'),
                'source': 'yfinance_fundamentals'
            }
            
        except Exception as e:
            self.logger.error(f"Failed to get fundamental data for {symbol}: {e}")
            return None

class RealAlpacaTrading:
    """Real Alpaca trading integration using secure configuration"""
    
    def __init__(self):
        self.config_manager = get_config()
        self.logger = logging.getLogger(__name__)
        
        # Get Alpaca configuration
        self.alpaca_config = self.config_manager.get_alpaca_config()
        self.trading_client = None
        
        # Initialize Alpaca client
        try:
            # Import Alpaca SDK
            from alpaca.trading.client import TradingClient
            from alpaca.trading.requests import MarketOrderRequest, LimitOrderRequest
            from alpaca.trading.enums import OrderSide, TimeInForce
            
            self.trading_client = TradingClient(
                api_key=self.alpaca_config['api_key'],
                secret_key=self.alpaca_config['secret_key'],
                paper=self.alpaca_config['paper_trading']
            )
        self.data_client = StockHistoricalDataClient(self.api_key, self.api_secret)
            
            # Test connection
            account = self.trading_client.get_account()
            self.logger.info(f"‚úÖ Alpaca connection established - Account: {account.status}")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize Alpaca client: {e}")
            self.trading_client = None
    
    def get_real_account_info(self) -> Optional[Dict]:
        """Get real account information"""
        if not self.trading_client:
            return None
        
        try:
            account = self.trading_client.get_account()
            
            return {
                'id': account.id,
                'account_number': account.account_number,
                'status': account.status,
                'currency': account.currency,
                'buying_power': float(account.buying_power),
                'cash': float(account.cash),
                'portfolio_value': float(account.portfolio_value),
                'equity': float(account.equity),
                'last_equity': float(account.last_equity),
                'multiplier': int(account.multiplier),
                'trading_blocked': account.trading_blocked,
                'transfers_blocked': account.transfers_blocked,
                'account_blocked': account.account_blocked,
                'created_at': account.created_at.isoformat() if account.created_at else None,
                'trade_suspended_by_user': account.trade_suspended_by_user,
                'pattern_day_trader': account.pattern_day_trader,
                'daytrade_count': account.daytrade_count,
                'daytrading_buying_power': float(account.daytrading_buying_power),
                'regt_buying_power': float(account.regt_buying_power),
                'source': 'alpaca_real'
            }
            
        except Exception as e:
            self.logger.error(f"Failed to get account info: {e}")
            return None
    
    def get_real_positions(self) -> List[Dict]:
        """Get real positions"""
        if not self.trading_client:
            return []
        
        try:
            positions = self.trading_client.get_all_positions()
            
            position_list = []
            for pos in positions:
                position_list.append({
                    'symbol': pos.symbol,
                    'qty': float(pos.qty),
                    'side': pos.side,
                    'market_value': float(pos.market_value) if pos.market_value else 0.0,
                    'cost_basis': float(pos.cost_basis) if pos.cost_basis else 0.0,
                    'unrealized_pl': float(pos.unrealized_pl) if pos.unrealized_pl else 0.0,
                    'unrealized_plpc': float(pos.unrealized_plpc) if pos.unrealized_plpc else 0.0,
                    'current_price': float(pos.current_price) if pos.current_price else 0.0,
                    'lastday_price': float(pos.lastday_price) if pos.lastday_price else 0.0,
                    'change_today': float(pos.change_today) if pos.change_today else 0.0,
                    'avg_cost': float(pos.avg_cost) if pos.avg_cost else 0.0,
                    'exchange': pos.exchange,
                    'asset_class': pos.asset_class
                })
            
            self.logger.info(f"‚úÖ Retrieved {len(position_list)} real positions")
            return position_list
            
        except Exception as e:
            self.logger.error(f"Failed to get positions: {e}")
            return []
    
    def get_real_orders(self, status: str = None) -> List[Dict]:
        """Get real orders"""
        if not self.trading_client:
            return []
        
        try:
            from alpaca.trading.requests import GetOrdersRequest
            from alpaca.trading.enums import QueryOrderStatus
            
            # Set up request
            request_params = {}
            if status:
                if status.upper() == 'OPEN':
                    request_params['status'] = QueryOrderStatus.OPEN
                elif status.upper() == 'CLOSED':
                    request_params['status'] = QueryOrderStatus.CLOSED
            
            request = GetOrdersRequest(**request_params) if request_params else GetOrdersRequest()
            orders = self.trading_client.get_orders(request)
            
            order_list = []
            for order in orders:
                order_list.append({
                    'id': order.id,
                    'client_order_id': order.client_order_id,
                    'symbol': order.symbol,
                    'side': order.side,
                    'order_type': order.order_type,
                    'time_in_force': order.time_in_force,
                    'qty': float(order.qty) if order.qty else 0.0,
                    'filled_qty': float(order.filled_qty) if order.filled_qty else 0.0,
                    'status': order.status,
                    'created_at': order.created_at.isoformat() if order.created_at else None,
                    'updated_at': order.updated_at.isoformat() if order.updated_at else None,
                    'submitted_at': order.submitted_at.isoformat() if order.submitted_at else None,
                    'filled_at': order.filled_at.isoformat() if order.filled_at else None,
                    'limit_price': float(order.limit_price) if order.limit_price else None,
                    'stop_price': float(order.stop_price) if order.stop_price else None,
                    'filled_avg_price': float(order.filled_avg_price) if order.filled_avg_price else None
                })
            
            self.logger.info(f"‚úÖ Retrieved {len(order_list)} real orders")
            return order_list
            
        except Exception as e:
            self.logger.error(f"Failed to get orders: {e}")
            return []

class RealTechnicalAnalysis:
    """Real technical analysis calculations using proper algorithms"""
    
    @staticmethod
    def calculate_rsi(prices: pd.Series, period: int = 14) -> Optional[float]:
        """Calculate real RSI"""
        if len(prices) < period + 1:
            return None
        
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        # Avoid division by zero
        rs = gain / loss.replace(0, np.inf)
        rsi = 100 - (100 / (1 + rs))
        
        return float(rsi.iloc[-1]) if not np.isnan(rsi.iloc[-1]) else None
    
    @staticmethod
    def calculate_macd(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Dict[str, Optional[float]]:
        """Calculate real MACD"""
        if len(prices) < slow:
            return {'macd': None, 'signal': None, 'histogram': None}
        
        exp_fast = prices.ewm(span=fast).mean()
        exp_slow = prices.ewm(span=slow).mean()
        macd_line = exp_fast - exp_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        
        return {
            'macd': float(macd_line.iloc[-1]) if not np.isnan(macd_line.iloc[-1]) else None,
            'signal': float(signal_line.iloc[-1]) if not np.isnan(signal_line.iloc[-1]) else None,
            'histogram': float(histogram.iloc[-1]) if not np.isnan(histogram.iloc[-1]) else None
        }
    
    @staticmethod
    def calculate_bollinger_bands(prices: pd.Series, period: int = 20, std_dev: int = 2) -> Dict[str, Optional[float]]:
        """Calculate real Bollinger Bands"""
        if len(prices) < period:
            return {'upper': None, 'middle': None, 'lower': None}
        
        middle = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        upper = middle + (std * std_dev)
        lower = middle - (std * std_dev)
        
        return {
            'upper': float(upper.iloc[-1]) if not np.isnan(upper.iloc[-1]) else None,
            'middle': float(middle.iloc[-1]) if not np.isnan(middle.iloc[-1]) else None,
            'lower': float(lower.iloc[-1]) if not np.isnan(lower.iloc[-1]) else None
        }
    
    @staticmethod
    def calculate_moving_averages(prices: pd.Series) -> Dict[str, Optional[float]]:
        """Calculate real moving averages"""
        result = {}
        
        periods = [5, 10, 20, 50, 100, 200]
        for period in periods:
            if len(prices) >= period:
                sma = prices.rolling(window=period).mean().iloc[-1]
                ema = prices.ewm(span=period).mean().iloc[-1]
                result[f'sma_{period}'] = float(sma) if not np.isnan(sma) else None
                result[f'ema_{period}'] = float(ema) if not np.isnan(ema) else None
            else:
                result[f'sma_{period}'] = None
                result[f'ema_{period}'] = None
        
        return result
    
    @staticmethod
    def calculate_volume_indicators(prices: pd.Series, volume: pd.Series) -> Dict[str, Optional[float]]:
        """Calculate volume-based indicators"""
        if len(prices) < 20 or len(volume) < 20:
            return {'vwap': None, 'volume_sma': None, 'volume_ratio': None}
        
        # VWAP (Volume Weighted Average Price)
        vwap = (prices * volume).cumsum() / volume.cumsum()
        
        # Volume SMA
        volume_sma = volume.rolling(window=20).mean()
        
        # Volume ratio (current vs average)
        current_volume = volume.iloc[-1]
        avg_volume = volume_sma.iloc[-1]
        volume_ratio = current_volume / avg_volume if avg_volume > 0 else None
        
        return {
            'vwap': float(vwap.iloc[-1]) if not np.isnan(vwap.iloc[-1]) else None,
            'volume_sma': float(volume_sma.iloc[-1]) if not np.isnan(volume_sma.iloc[-1]) else None,
            'volume_ratio': float(volume_ratio) if volume_ratio and not np.isnan(volume_ratio) else None
        }

class RealAIAnalyzer:
    """Real AI analysis using OpenRouter"""
    
    def __init__(self):
        self.config_manager = get_config()
        self.openrouter_config = self.config_manager.get_openrouter_config()
        self.logger = logging.getLogger(__name__)
    
    async def get_real_ai_analysis(self, symbol: str, market_data: Dict, technical_data: Dict, fundamental_data: Dict = None) -> Optional[Dict]:
        """Get real AI analysis from OpenRouter"""
        try:
            # Prepare comprehensive analysis context
            context = self._prepare_analysis_context(symbol, market_data, technical_data, fundamental_data)
            
            headers = {
                "Authorization": f"Bearer {self.openrouter_config['api_key']}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": "deepseek/deepseek-r1:free",
                "messages": [
                    {
                        "role": "system", 
                        "content": "You are a professional quantitative analyst. Provide trading recommendations based on technical and fundamental analysis."
                    },
                    {
                        "role": "user", 
                        "content": context
                    }
                ],
                "max_tokens": 500,
                "temperature": 0.7
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.openrouter_config['base_url'],
                    json=payload,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    
                    if response.status == 200:
                        result = await response.json()
                        ai_content = result['choices'][0]['message']['content']
                        
                        # Parse AI response
                        parsed_analysis = self._parse_ai_response(ai_content)
                        parsed_analysis['source'] = 'openrouter_real'
                        parsed_analysis['model'] = 'deepseek-r1'
                        parsed_analysis['full_response'] = ai_content
                        
                        self.logger.info(f"‚úÖ Real AI analysis completed for {symbol}")
                        return parsed_analysis
                    
                    else:
                        self.logger.error(f"OpenRouter API error: {response.status}")
                        return None
            
        except Exception as e:
            self.logger.error(f"AI analysis failed for {symbol}: {e}")
            return None
    
    def _prepare_analysis_context(self, symbol: str, market_data: Dict, technical_data: Dict, fundamental_data: Dict = None) -> str:
        """Prepare comprehensive analysis context for AI"""
        context = f"""
        Analyze {symbol} for trading opportunities using this real market data:
        
        MARKET DATA:
        - Current Price: ${market_data.get('price', 0):.2f}
        - Change: {market_data.get('change_percent', '0%')}
        - Volume: {market_data.get('volume', 0):,}
        - Bid/Ask: ${market_data.get('bid', 0):.2f}/${market_data.get('ask', 0):.2f}
        
        TECHNICAL INDICATORS:
        - RSI: {technical_data.get('rsi', 'N/A')}
        - MACD: {technical_data.get('macd', {}).get('macd', 'N/A')} (Signal: {technical_data.get('macd', {}).get('signal', 'N/A')})
        - Bollinger Bands: Upper ${technical_data.get('bollinger', {}).get('upper', 'N/A')}, Lower ${technical_data.get('bollinger', {}).get('lower', 'N/A')}
        - SMA 20: ${technical_data.get('moving_averages', {}).get('sma_20', 'N/A')}
        - SMA 50: ${technical_data.get('moving_averages', {}).get('sma_50', 'N/A')}
        - Volume Ratio: {technical_data.get('volume', {}).get('volume_ratio', 'N/A')}
        """
        
        if fundamental_data:
            context += f"""
        
        FUNDAMENTAL DATA:
        - P/E Ratio: {fundamental_data.get('pe_ratio', 'N/A')}
        - Market Cap: ${fundamental_data.get('market_cap', 0):,}
        - Beta: {fundamental_data.get('beta', 'N/A')}
        - Sector: {fundamental_data.get('sector', 'N/A')}
        - Industry: {fundamental_data.get('industry', 'N/A')}
            """
        
        context += """
        
        Please provide:
        1. RECOMMENDATION: BUY/SELL/HOLD
        2. CONFIDENCE: 1-100
        3. TARGET_PRICE: Your price target
        4. STOP_LOSS: Suggested stop loss
        5. REASONING: Brief explanation (2-3 sentences)
        6. RISK_LEVEL: LOW/MEDIUM/HIGH
        7. TIME_HORIZON: SHORT/MEDIUM/LONG
        
        Format your response clearly with these labels.
        """
        
        return context
    
    def _parse_ai_response(self, ai_content: str) -> Dict:
        """Parse AI response into structured data"""
        # Default values
        result = {
            'recommendation': 'HOLD',
            'confidence': 50,
            'target_price': None,
            'stop_loss': None,
            'reasoning': 'No clear recommendation provided',
            'risk_level': 'MEDIUM',
            'time_horizon': 'MEDIUM'
        }
        
        # Parse response
        content_upper = ai_content.upper()
        
        # Extract recommendation
        if 'RECOMMENDATION:' in content_upper:
            rec_section = ai_content.split('RECOMMENDATION:')[1].split('\n')[0]
            if 'BUY' in rec_section.upper():
                result['recommendation'] = 'BUY'
            elif 'SELL' in rec_section.upper():
                result['recommendation'] = 'SELL'
            else:
                result['recommendation'] = 'HOLD'
        
        # Extract confidence
        if 'CONFIDENCE:' in content_upper:
            try:
                conf_section = ai_content.split('CONFIDENCE:')[1].split('\n')[0]
                confidence = float(''.join(filter(str.isdigit, conf_section)))
                result['confidence'] = min(max(confidence, 0), 100)
            except Exception:
                pass
        
        # Extract reasoning
        if 'REASONING:' in content_upper:
            reasoning_section = ai_content.split('REASONING:')[1].split('\n')[0:3]
            result['reasoning'] = ' '.join(reasoning_section).strip()
        
        # Extract risk level
        if 'RISK_LEVEL:' in content_upper:
            risk_section = ai_content.split('RISK_LEVEL:')[1].split('\n')[0]
            if 'HIGH' in risk_section.upper():
                result['risk_level'] = 'HIGH'
            elif 'LOW' in risk_section.upper():
                result['risk_level'] = 'LOW'
            else:
                result['risk_level'] = 'MEDIUM'
        
        return result

class RobustRealTradingSystem:
    """Complete robust real trading system with NO synthetic data"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Initialize components
        self.market_data = RealMarketDataProvider()
        self.alpaca_trading = RealAlpacaTrading()
        self.ai_analyzer = RealAIAnalyzer()
        
        # Validate configuration
        validation = self.market_data.config_manager.validate_credentials()
        if not validation['all_configured']:
            self.logger.warning("‚ö†Ô∏è Some credentials missing - functionality may be limited")
        
        self.logger.info("‚úÖ Robust Real Trading System initialized with 100% real data sources")
    
    async def analyze_symbol_complete(self, symbol: str) -> Optional[Dict]:
        """Complete real analysis of a symbol"""
        self.logger.info(f"üîç Analyzing {symbol} with real data only")
        
        try:
            # Get real market data
            quote = await self.market_data.get_real_quote(symbol)
            if not quote:
                self.logger.error(f"Failed to get real market data for {symbol}")
                return None
            
            # Get real historical data
            historical = await self.market_data.get_real_historical_data(symbol)
            if historical is None or historical.empty:
                self.logger.error(f"Failed to get real historical data for {symbol}")
                return None
            
            # Calculate real technical indicators
            close_prices = historical['Close']
            volume = historical['Volume']
            
            technical_analysis = {
                'rsi': RealTechnicalAnalysis.calculate_rsi(close_prices),
                'macd': RealTechnicalAnalysis.calculate_macd(close_prices),
                'bollinger': RealTechnicalAnalysis.calculate_bollinger_bands(close_prices),
                'moving_averages': RealTechnicalAnalysis.calculate_moving_averages(close_prices),
                'volume': RealTechnicalAnalysis.calculate_volume_indicators(close_prices, volume)
            }
            
            # Get real fundamental data
            fundamental_data = await self.market_data.get_real_fundamental_data(symbol)
            
            # Get real AI analysis
            ai_analysis = await self.ai_analyzer.get_real_ai_analysis(
                symbol, quote, technical_analysis, fundamental_data
            )
            
            # Generate final trading signal
            trading_signal = self._generate_trading_signal(quote, technical_analysis, ai_analysis)
            
            result = {
                'symbol': symbol,
                'timestamp': datetime.now().isoformat(),
                'market_data': quote,
                'technical_analysis': technical_analysis,
                'fundamental_data': fundamental_data,
                'ai_analysis': ai_analysis,
                'trading_signal': trading_signal,
                'data_quality': 'real_only'
            }
            
            self.logger.info(f"‚úÖ Complete real analysis finished for {symbol}")
            return result
            
        except Exception as e:
            self.logger.error(f"Analysis failed for {symbol}: {e}")
            return None
    
    def _generate_trading_signal(self, market_data: Dict, technical: Dict, ai: Dict) -> Dict:
        """Generate trading signal from real data"""
        score = 0
        signals = []
        
        # AI signal weight (highest priority)
        if ai and ai.get('recommendation'):
            ai_rec = ai['recommendation']
            ai_confidence = ai.get('confidence', 50) / 100
            
            if ai_rec == 'BUY':
                score += 3 * ai_confidence
                signals.append(f"AI recommends BUY (confidence: {ai.get('confidence', 50)}%)")
            elif ai_rec == 'SELL':
                score -= 3 * ai_confidence
                signals.append(f"AI recommends SELL (confidence: {ai.get('confidence', 50)}%)")
            else:
                signals.append("AI recommends HOLD")
        
        # Technical signals
        rsi = technical.get('rsi')
        if rsi is not None:
            if rsi < 30:
                score += 1.5
                signals.append(f"RSI oversold ({rsi:.1f})")
            elif rsi > 70:
                score -= 1.5
                signals.append(f"RSI overbought ({rsi:.1f})")
        
        # MACD signal
        macd_data = technical.get('macd', {})
        if macd_data.get('histogram') is not None:
            if macd_data['histogram'] > 0:
                score += 1
                signals.append("MACD bullish")
            else:
                score -= 1
                signals.append("MACD bearish")
        
        # Moving average signals
        ma_data = technical.get('moving_averages', {})
        sma_20 = ma_data.get('sma_20')
        sma_50 = ma_data.get('sma_50')
        current_price = market_data.get('price', 0)
        
        if sma_20 and sma_50 and current_price:
            if sma_20 > sma_50 and current_price > sma_20:
                score += 1
                signals.append("Price above rising MA")
            elif sma_20 < sma_50 and current_price < sma_20:
                score -= 1
                signals.append("Price below falling MA")
        
        # Generate final signal
        if score > 2:
            final_signal = 'STRONG_BUY'
        elif score > 0.5:
            final_signal = 'BUY'
        elif score < -2:
            final_signal = 'STRONG_SELL'
        elif score < -0.5:
            final_signal = 'SELL'
        else:
            final_signal = 'HOLD'
        
        return {
            'signal': final_signal,
            'score': score,
            'strength': abs(score),
            'signals': signals,
            'recommendation': 'Consider position' if abs(score) > 1 else 'Monitor'
        }
    
    async def run_complete_analysis(self, symbols: List[str]) -> Dict:
        """Run complete analysis on multiple symbols"""
        self.logger.info(f"üöÄ Running complete real analysis on {len(symbols)} symbols")
        
        # Get real account info
        account_info = self.alpaca_trading.get_real_account_info()
        positions = self.alpaca_trading.get_real_positions()
        orders = self.alpaca_trading.get_real_orders()
        
        # Analyze symbols
        symbol_analyses = {}
        for symbol in symbols:
            analysis = await self.analyze_symbol_complete(symbol)
            if analysis:
                symbol_analyses[symbol] = analysis
            else:
                symbol_analyses[symbol] = {'error': 'Failed to get real data'}
        
        return {
            'timestamp': datetime.now().isoformat(),
            'account_info': account_info,
            'positions': positions,
            'orders': orders,
            'symbol_analyses': symbol_analyses,
            'system_status': 'real_data_only',
            'total_symbols_analyzed': len([s for s in symbol_analyses.values() if 'error' not in s])
        }
    
    def display_results(self, results: Dict):
        """Display comprehensive results"""
        print("\n" + "="*100)
        print("üéØ ROBUST REAL TRADING SYSTEM - 100% REAL DATA ANALYSIS")
        print("="*100)
        
        # Account information
        account = results.get('account_info')
        if account:
            print(f"\nüí∞ ACCOUNT INFORMATION ({account.get('status', 'unknown')})")
            print(f"   Portfolio Value: ${account.get('portfolio_value', 0):,.2f}")
            print(f"   Buying Power: ${account.get('buying_power', 0):,.2f}")
            print(f"   Cash: ${account.get('cash', 0):,.2f}")
            print(f"   Day Trade Count: {account.get('daytrade_count', 0)}")
        else:
            print("\nüí∞ ACCOUNT: Real API connection failed")
        
        # Positions
        positions = results.get('positions', [])
        print(f"\nüìä POSITIONS ({len(positions)} active)")
        for pos in positions[:5]:  # Show first 5
            print(f"   {pos['symbol']}: {pos['qty']} shares @ ${pos['current_price']:.2f} "
                  f"(P&L: ${pos['unrealized_pl']:.2f})")
        
        # Symbol analyses
        analyses = results.get('symbol_analyses', {})
        print(f"\nüìà SYMBOL ANALYSIS ({len(analyses)} symbols):")
        
        for symbol, analysis in analyses.items():
            if 'error' in analysis:
                print(f"\n‚ùå {symbol}: {analysis['error']}")
                continue
            
            market = analysis['market_data']
            technical = analysis['technical_analysis']
            ai = analysis.get('ai_analysis', {})
            signal = analysis['trading_signal']
            fundamental = analysis.get('fundamental_data', {})
            
            print(f"\nüìä {symbol} (Real data from {market['source']}):")
            print(f"   Price: ${market['price']:.2f} ({market['change_percent']}) | Volume: {market['volume']:,}")
            
            if technical['rsi']:
                print(f"   RSI: {technical['rsi']:.1f} | MACD: {technical['macd']['macd']:.3f}")
            
            if fundamental and fundamental.get('pe_ratio'):
                print(f"   P/E: {fundamental['pe_ratio']:.1f} | Sector: {fundamental.get('sector', 'N/A')}")
            
            if ai:
                print(f"   AI: {ai['recommendation']} ({ai['confidence']}% confidence) | {ai['risk_level']} risk")
                print(f"   Reasoning: {ai['reasoning'][:80]}...")
            
            print(f"   üéØ SIGNAL: {signal['signal']} (Score: {signal['score']:.1f})")
            if signal['signals']:
                print(f"   Factors: {', '.join(signal['signals'][:3])}")
        
        print(f"\n‚úÖ Analysis completed: {results['timestamp']}")
        print("üî• 100% REAL DATA - No synthetic/mock data used!")
        print(f"üìä Successfully analyzed: {results['total_symbols_analyzed']} symbols")

async def main():
    """Main function to demonstrate the system"""
    print("üöÄ ROBUST REAL TRADING SYSTEM")
    print("="*70)
    print("‚úÖ Real yfinance market data")
    print("‚úÖ Real Alpaca trading API")
    print("‚úÖ Real OpenRouter AI analysis")
    print("‚úÖ Real technical calculations")
    print("‚úÖ Secure credential management")
    print("‚ùå NO synthetic data")
    print("‚ùå NO placeholders")
    print("‚ùå NO fake fallbacks")
    print("="*70)
    
    # Initialize system
    system = RobustRealTradingSystem()
    
    # Test symbols
    test_symbols = ['AAPL', 'TSLA', 'SPY', 'NVDA', 'MSFT']
    
    # Run complete analysis
    results = await system.run_complete_analysis(test_symbols)
    
    # Display results
    system.display_results(results)

if __name__ == "__main__":
    asyncio.run(main())